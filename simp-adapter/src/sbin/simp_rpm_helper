#!/usr/bin/env ruby
#
# Purpose
# -------
#
# This script is meant to be called by the %preun and %post sections of the
# various SIMP Puppet module RPMs.
#
# The purpose of the script is to provide helper methods that correctly
# scaffold the system in such a way that all SIMP Puppet Modules can be
# installed via RPM to a single location and subsequently can be copied into
# the standard SIMP installation location based on the version of Puppet that
# is installed.
#
# Care is taken that, should the target directory be managed via 'git', this
# script will do nothing to harm the managed installation in any way. This
# ensures that the SIMP modules have maximum compatibility with the widest
# possible range of Puppet module best practices for management while ensuring
# that the RPM installations and upgrades can proceed in a seamless fashion
# over time.
#
#
# Options
# -------
#
# The script must be passed the following options:
#   module_path (String) => The full installation path of the module from the RPM
#   rpm_section (String) => One of 'pre', 'post', 'preun', or 'postun'
#   rpm_status (Integer) => The associated upgrade status per the following map
#     'pre' :
#       1 : 'install'
#       2 : 'upgrade'
#     'post' :
#       1 : 'install'
#       2 : 'upgrade'
#     'preun' :
#       1 : 'uninstall of the old version during upgrade'
#       0 : 'uninstall of the only version during erase'
#     'postun' :
#       1 : 'uninstall of the old version during upgrade'
#       0 : 'uninstall of the only version during erase'
#
# Should the 'simp' environment not be found, the script will simply exit
# without copying any files.
#
# Configuration
# -------------
#
# A configuration file may be placed at /etc/simp/simp_adapter_config.yaml. The
# file must consist of proper YAML as demonstrated in the example below which
# lists the default options.
#
# Any configuration options that are not understood will be ignored.
#
# ```yaml
#   ---
#   # Target directory
#   # May be set to a fully qualified path or 'auto'
#   # If set to 'auto', the directory will be determined from puppet itself
#
#   target_directory : 'auto'
#
#   # Copy the RPM data to the target directory
#
#   copy_rpm_data : true
#
# ```
#

require 'facter'
require 'fileutils'
require 'yaml'

# A more friendly failure message
def fail(msg)
  $stderr.puts(msg)
  exit(1)
end

# Determine whether the passed path is under management by git or svn
def is_managed?(path)
  # Short circuit if the directory is not present
  return false unless File.directory?(path)

  git = Facter::Core::Execution.which('git')
  svn = Facter::Core::Execution.which('svn')

  Dir.chdir(path) do
    if git
      %x{#{git} ls-files . --error-unmatch}

      return true if $?.success?
    end

    if svn
      %x{#{svn} info}

      return true if $?.success?
    end
  end

  return false
end

# Process the config, validate the entries and do some munging
def process_config(config_file)
  config = {
    'target_directory' => 'auto',
    'copy_rpm_data'    => true
  }

  if File.exist?(config_file)
    begin
      config.merge!(YAML.parse_file(config_file))
    rescue
      fail("Error: Config file '#{config_file}' could not be processed")
    end
  end

  config['copy_rpm_data'] = (config['copy_rpm_data'].to_s == 'true')

  if config['target_directory'] == 'auto'
    config['target_directory'] = puppet_module_dir
  end

  unless config['target_directory'][0].chr == '/'
    fail("Error: 'target_directory' in '#{config_file}' must be an absolute path")
  end

  return config
end

# Return the Puppet module installation directory
def puppet_module_dir
  # Figure out where the Puppet code should go
  # Puppet 4+
  install_target = %x{puppet config print codedir}.strip
  if install_target.empty?
    install_target = %x{puppet config print confdir}.strip
  end

  if install_target.empty?
    fail('Error: Could not find a Puppet code directory for installation')
  end

  return File.join(install_target,'environments','simp','modules')
end

# Input Validation
def validate_input(module_path, rpm_section, rpm_status)

  unless module_path && rpm_section && rpm_status
    fail("Usage: #{$0} <module_path> <rpm_section> <rpm_status>")
  end

  unless module_path[0].chr == '/'
    fail("Error: The first argument must be an absolute path")
  end

  valid_rpm_sections = ['pre','post','preun','postun']

  unless valid_rpm_sections.include?(rpm_section)
    fail("Error: The second argument must be one of '#{valid_rpm_sections.join("', '")}'")
  end

  unless rpm_status =~ /^\d+$/
    fail("Error: The third argument must be an integer")
  end
end

# Process the input options
module_path = ARGV[0]
rpm_section = ARGV[1]
rpm_status = ARGV[2]
config_file = '/etc/simp/simp_adapter_config.yaml'

validate_input(module_path, rpm_section, rpm_status)

module_path = module_path.strip
rpm_section = rpm_section.strip
rpm_status = rpm_status.strip

unless File.directory?(module_path)
  fail("Error: Could not find module path '#{module_path}'")
end

module_name = File.basename(module_path)

puppet_group = %x{puppet config print group}.strip
fail('Error: Could not determine puppet group') if puppet_group.empty?

config = process_config(config_file)

target_dir = config['target_directory']

# A list of modules that should never be touched once installed
safe_modules = ['site']

# If the target directory is managed, we're done
unless is_managed?(target_dir) && config['copy_rpm_data']

  rsync = Facter::Core::Execution.which('rsync')
  fail("Error: Could not find 'rsync' command!") unless rsync

  # A regular installation or upgrade
  if rpm_section == 'post'
    if rpm_status == '2'
      # Short circuit on upgrading safe modules, just don't touch them!
      if safe_modules.include?(module_name)
        if File.directory?(File.join(target_dir,module_name))
          exit(0)
        end
      end
    end

    # Create the directories, with the proper mode, all the way down
    dir_paths = target_dir.split(File::SEPARATOR).reject(&:empty?)
    top_dir = File::SEPARATOR + dir_paths.shift
    unless File.directory?(top_dir)
      FileUtils.mkdir(top_dir, :mode => 0750)
      FileUtils.chown('root', puppet_group, top_dir)
    end

    Dir.chdir(top_dir) do
      dir_paths.each do |dir|
        unless File.directory?(dir)
          FileUtils.mkdir(top_dir, :mode => 0750)
          FileUtils.chown('root', puppet_group, top_dir)
        end
      end
    end

    cmd = %(#{rsync} -a --delete --force #{module_path} #{File.join(target_dir, module_name)})

    output = %x{#{cmd}}
    unless $?.success?
      fail("Error: Copy of '#{module_name}' into '#{target_dir}' using '#{cmd}' failed with the following error:\n#{output}")
    end
  end

  # A regular uninstall or downgrade
  if rpm_section == 'postun' && rpm_status == '0'
    # Play it safe, this needs to have at least 'environments/simp/modules' in it!
    if target_dir.split(File::SEPARATOR).reject(&:empty?) < 3
      fail("Error: Not removing directory '#{target_dir}' for safety")
    else
      unless safe_modules.include?(module_name)
        to_del = File.join(target_dir, module_name)
        FileUtils.rm_rf(to_del, :secure => true)
      end
    end
  end
end
